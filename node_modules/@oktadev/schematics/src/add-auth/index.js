"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ionicRemoteConfig = exports.cordovaNode = exports.addAuth = exports.EXPRESS = exports.IONIC_ANGULAR = exports.VUE_TS = exports.VUE = exports.REACT_NATIVE = exports.REACT_TS = exports.REACT = exports.ANGULAR = void 0;
const core_1 = require("@angular-devkit/core");
const schematics_1 = require("@angular-devkit/schematics");
const tasks_1 = require("@angular-devkit/schematics/tasks");
const schematics_utilities_1 = require("schematics-utilities");
const workspace_1 = require("@schematics/angular/utility/workspace");
const project_targets_1 = require("@schematics/angular/utility/project-targets");
function addPackageJsonDependencies(framework, options) {
    return (host, context) => {
        const dependencies = [];
        if (framework === exports.ANGULAR) {
            dependencies.push({ type: schematics_utilities_1.NodeDependencyType.Default, version: '3.0.1', name: '@okta/okta-angular' });
        }
        else if (framework === exports.REACT || framework === exports.REACT_TS) {
            dependencies.push({ type: schematics_utilities_1.NodeDependencyType.Default, version: '4.0.0', name: '@okta/okta-react' });
            dependencies.push({ type: schematics_utilities_1.NodeDependencyType.Default, version: '4.2.0', name: '@okta/okta-auth-js' });
            dependencies.push({ type: schematics_utilities_1.NodeDependencyType.Default, version: '5.2.0', name: 'react-router-dom' });
            if (framework === exports.REACT_TS) {
                dependencies.push({ type: schematics_utilities_1.NodeDependencyType.Default, version: '5.1.6', name: '@types/react-router-dom' });
            }
        }
        else if (framework === exports.REACT_NATIVE) {
            dependencies.push({ type: schematics_utilities_1.NodeDependencyType.Default, version: '1.4.4', name: '@okta/okta-react-native' });
            dependencies.push({ type: schematics_utilities_1.NodeDependencyType.Default, version: '3.2.0', name: 'events' });
            dependencies.push({ type: schematics_utilities_1.NodeDependencyType.Dev, version: '3.11.0', name: 'enzyme' });
            dependencies.push({ type: schematics_utilities_1.NodeDependencyType.Dev, version: '1.15.5', name: 'enzyme-adapter-react-16' });
            dependencies.push({ type: schematics_utilities_1.NodeDependencyType.Dev, version: '0.9.1', name: 'enzyme-async-helpers' });
            dependencies.push({ type: schematics_utilities_1.NodeDependencyType.Dev, version: '17.0.1', name: 'react-dom' });
        }
        else if (framework === exports.VUE || framework == exports.VUE_TS) {
            dependencies.push({ type: schematics_utilities_1.NodeDependencyType.Default, version: '2.1.1', name: '@okta/okta-vue' });
            if (framework === exports.VUE_TS) {
                dependencies.push({ type: schematics_utilities_1.NodeDependencyType.Dev, version: '1.2.2', name: '@types/okta__okta-vue' });
            }
        }
        else if (framework === exports.IONIC_ANGULAR) {
            dependencies.push({ type: schematics_utilities_1.NodeDependencyType.Default, version: '0.7.4', name: 'ionic-appauth' });
            dependencies.push({ type: schematics_utilities_1.NodeDependencyType.Default, version: '5.30.0', name: '@ionic-native/secure-storage' });
            if (options.platform === 'capacitor') {
                dependencies.push({
                    type: schematics_utilities_1.NodeDependencyType.Default,
                    version: '5.1.1',
                    name: 'cordova-plugin-secure-storage-echo'
                });
                dependencies.push({ type: schematics_utilities_1.NodeDependencyType.Default, version: '3.1.0', name: 'cordova-plugin-advanced-http' });
                dependencies.push({
                    type: schematics_utilities_1.NodeDependencyType.Default,
                    version: '1.6.0',
                    name: 'cordova-plugin-safariviewcontroller'
                });
                dependencies.push({ type: schematics_utilities_1.NodeDependencyType.Default, version: '5.30.0', name: '@ionic-native/http' });
            }
            else {
                dependencies.push({ type: schematics_utilities_1.NodeDependencyType.Default, version: '2.3.1', name: '@ionic/storage' });
            }
        }
        else if (framework === exports.EXPRESS) {
            dependencies.push({ type: schematics_utilities_1.NodeDependencyType.Default, version: '1.17.1', name: 'express-session' });
            dependencies.push({ type: schematics_utilities_1.NodeDependencyType.Default, version: '4.0.1', name: '@okta/oidc-middleware' });
            dependencies.push({ type: schematics_utilities_1.NodeDependencyType.Default, version: '8.2.0', name: 'dotenv' });
        }
        dependencies.forEach(dependency => {
            schematics_utilities_1.addPackageJsonDependency(host, dependency);
            // @ts-ignore
            context.logger.log('info', `âœ…ï¸ Added '${dependency.name}' into ${dependency.type}`);
        });
        return host;
    };
}
function installPackageJsonDependencies() {
    return (host, context) => {
        context.addTask(new tasks_1.NodePackageInstallTask());
        context.logger.log('info', `ðŸ” Installing packages...`);
        return host;
    };
}
exports.ANGULAR = 'angular';
exports.REACT = 'react';
exports.REACT_TS = 'react-ts';
exports.REACT_NATIVE = 'react-native';
exports.VUE = 'vue';
exports.VUE_TS = 'vue-ts';
exports.IONIC_ANGULAR = 'ionic/angular';
exports.EXPRESS = 'express';
function getFramework(host) {
    let possibleFiles = ['/package.json'];
    const path = possibleFiles.filter(path => host.exists(path))[0];
    const configBuffer = host.read(path);
    if (configBuffer === null) {
        throw new schematics_1.SchematicsException(`Could not find (${path})`);
    }
    else {
        const content = JSON.parse(configBuffer.toString());
        if (content.dependencies['@angular/core'] && !content.dependencies['@ionic/angular']) {
            return exports.ANGULAR;
        }
        else if (content.dependencies['react']) {
            if (content.dependencies['react-native']) {
                return exports.REACT_NATIVE;
            }
            if (content.dependencies['typescript']) {
                return exports.REACT_TS;
            }
            return exports.REACT;
        }
        else if (content.dependencies['vue']) {
            if (content.devDependencies['typescript']) {
                return exports.VUE_TS;
            }
            return exports.VUE;
        }
        else if (content.dependencies['@ionic/angular']) {
            return exports.IONIC_ANGULAR;
        }
        else if (content.dependencies['express']) {
            return exports.EXPRESS;
        }
        else {
            throw new schematics_1.SchematicsException('No supported frameworks found in your package.json!');
        }
    }
}
function addAuth(options) {
    return (host) => __awaiter(this, void 0, void 0, function* () {
        var _a;
        // allow passing the framework in (for testing)
        let framework = options.framework;
        // if no framework defined, try to detect it
        if (!framework) {
            framework = getFramework(host);
        }
        let projectPath = './';
        if (framework === exports.ANGULAR) {
            const workspace = yield workspace_1.getWorkspace(host);
            if (!options.issuer) {
                throw new schematics_1.SchematicsException('You must specify an "issuer".');
            }
            if (!options.project) {
                options.project = workspace.projects.keys().next().value;
            }
            const project = workspace.projects.get(options.project);
            if (!project) {
                throw new schematics_1.SchematicsException(`Invalid project name: ${options.project}`);
            }
            projectPath = project.root;
            const buildTarget = (_a = project.targets) === null || _a === void 0 ? void 0 : _a.get('build');
            if (!buildTarget) {
                throw project_targets_1.targetBuildNotFoundError();
            }
            const buildOptions = (buildTarget.options || {});
            if (buildOptions.styles) {
                let style = buildOptions.styles[0];
                if (style) {
                    options.style = style.substring(style.lastIndexOf('.') + 1, style.length);
                }
                else {
                    options.style = 'css';
                }
            }
            // add imports to app.module.ts
            schematics_utilities_1.addModuleImportToModule(host, projectPath + '/src/app/app.module.ts', 'AuthRoutingModule', './auth-routing.module');
        }
        if (framework == exports.IONIC_ANGULAR) {
            // add a package name from the issuer
            const parts = options.issuer.split('.');
            if (options.issuer.indexOf('.') === -1) {
                // hard-code a package name for localhost
                options.packageName = 'dev.localhost.ionic';
            }
            else {
                options.packageName =
                    parts[2].substring(0, parts[2].indexOf('/')) + '.'
                        + parts[1] + '.'
                        + parts[0].substring(parts[0].lastIndexOf('/') + 1);
            }
            // create AuthConfigService for JHipster
            if (options.configUri) {
                host.create('src/app/auth/auth-config.service.ts', ionicRemoteConfig(options.configUri));
            }
            // add cordova to package.json
            if (options.platform === 'cordova') {
                const content = host.read('./package.json');
                if (content) {
                    const pkgJson = JSON.parse(content.toString());
                    // save any pre-existing plugins
                    if (pkgJson.cordova && pkgJson.cordova.plugins) {
                        const existingPlugins = pkgJson.cordova.plugins;
                        pkgJson.cordova.plugins = Object.assign(Object.assign({}, cordovaNode(options.packageName).plugins), existingPlugins);
                        pkgJson.cordova.platforms = cordovaNode(options.packageName).platforms;
                    }
                    else {
                        pkgJson.cordova = cordovaNode(options.packageName);
                    }
                    host.overwrite('./package.json', JSON.stringify(pkgJson));
                }
                schematics_utilities_1.addModuleImportToModule(host, 'src/app/app.module.ts', 'IonicStorageModule.forRoot()', '@ionic/storage');
            }
            // add imports to app.module.ts
            schematics_utilities_1.addModuleImportToModule(host, 'src/app/app.module.ts', 'HttpClientModule', '@angular/common/http');
            schematics_utilities_1.addModuleImportToModule(host, 'src/app/app.module.ts', 'AuthModule', './auth/auth.module');
        }
        if (framework === exports.REACT || framework === exports.REACT_TS) {
            const jestConfig = {
                'moduleNameMapper': {
                    '^@okta/okta-auth-js$': '<rootDir>/node_modules/@okta/okta-auth-js/dist/okta-auth-js.umd.js'
                }
            };
            const content = host.read('./package.json');
            if (content) {
                const pkgJson = JSON.parse(content.toString());
                pkgJson.jest = jestConfig;
                host.overwrite('./package.json', JSON.stringify(pkgJson));
            }
        }
        if (framework === exports.REACT_NATIVE) {
            // add a package name from the issuer
            const parts = options.issuer.split('.');
            options.packageName = parts[2].substring(0, parts[2].indexOf('/')) + '.'
                + parts[1] + '.' + parts[0].substring(parts[0].lastIndexOf('/') + 1);
            const content = host.read('./package.json');
            if (content) {
                const pkgJson = JSON.parse(content.toString());
                // add jest config for tests
                pkgJson.jest = {
                    'preset': 'react-native',
                    'automock': false,
                    'transformIgnorePatterns': [
                        'node_modules/(?!@okta|react-native)'
                    ],
                    'testMatch': ['**/tests/*.js?(x)', '**/?(*.)(spec|test).js?(x)'],
                    'setupFiles': [
                        './setupJest.js'
                    ]
                    // The reason tests are in `tests` instead of `__tests__` is because
                    // schematics uses double underscore as a substitution indicator in filenames.
                    // If you try to put tests in __tests__, you'll get an error:
                    // Error: Option "tests" is not defined.
                };
                host.overwrite('./package.json', JSON.stringify(pkgJson));
                // Upgrade iOS to v11
                const podfile = host.read('./ios/Podfile');
                if (podfile) {
                    const ios11 = podfile.toString('utf-8').replace('platform :ios, \'10.0\'', 'platform :ios, \'11.0\'');
                    const oktaOidc = ios11.replace('config = use_native_modules!', 'pod \'OktaOidc\', \'~> 3.0\'\n' +
                        '  \n' +
                        '  config = use_native_modules!');
                    host.overwrite('ios/Podfile', oktaOidc);
                }
                // Configure Gradle for Android
                const androidBuild = host.read('./android/build.gradle');
                if (androidBuild) {
                    const minSDK = androidBuild.toString('utf-8').replace('minSdkVersion = 16', 'minSdkVersion = 19');
                    const maven = minSDK.toString()
                        .replace('maven { url \'https://www.jitpack.io\' }', 'maven { url \'https://www.jitpack.io\' }\n' +
                        '        maven { url \'https://dl.bintray.com/okta/com.okta.android\' }');
                    host.overwrite('android/build.gradle', maven);
                }
                // Configure Gradle for App
                const appBuild = host.read('./android/app/build.gradle');
                if (appBuild) {
                    const redirectScheme = appBuild.toString('utf-8')
                        .replace('versionName "1.0"', 'versionName "1.0"\n        manifestPlaceholders = [ appAuthRedirectScheme: "' + options.packageName + '" ]');
                    host.overwrite('android/app/build.gradle', redirectScheme);
                }
            }
        }
        // Setup templates to add to the project
        const sourceDir = (framework !== exports.REACT_NATIVE && framework !== exports.EXPRESS) ? 'src' : '';
        const sourcePath = core_1.join(core_1.normalize(projectPath), sourceDir);
        const templatesPath = core_1.join(sourcePath, '');
        const templateSource = schematics_1.apply(schematics_1.url(`./${framework}/${sourceDir}`), [
            schematics_1.template(Object.assign({}, options)),
            schematics_1.move(core_1.getSystemPath(templatesPath)),
            // fix for https://github.com/angular/angular-cli/issues/11337
            schematics_1.forEach((fileEntry) => {
                if (host.exists(fileEntry.path)) {
                    host.overwrite(fileEntry.path, fileEntry.content);
                }
                return fileEntry;
            }),
        ]);
        // Chain the rules and return
        return schematics_1.chain([
            options && options.skipPackageJson ? schematics_1.noop() : addPackageJsonDependencies(framework, options),
            options && options.skipPackageJson ? schematics_1.noop() : installPackageJsonDependencies(),
            schematics_1.mergeWith(templateSource, schematics_1.MergeStrategy.Overwrite),
        ]);
    });
}
exports.addAuth = addAuth;
function cordovaNode(packageName) {
    return {
        'plugins': {
            'cordova-plugin-advanced-http': {},
            'cordova-plugin-safariviewcontroller': {},
            'cordova-plugin-inappbrowser': {},
            'cordova-plugin-secure-storage-echo': {},
            'cordova-plugin-customurlscheme': {
                'URL_SCHEME': packageName
            },
            'cordova-plugin-whitelist': {},
            'cordova-plugin-statusbar': {},
            'cordova-plugin-device': {},
            'cordova-plugin-splashscreen': {},
            'cordova-plugin-ionic-webview': {
                'ANDROID_SUPPORT_ANNOTATIONS_VERSION': '27.+'
            },
            'cordova-plugin-ionic-keyboard': {}
        },
        'platforms': [
            'android',
            'ios'
        ]
    };
}
exports.cordovaNode = cordovaNode;
function ionicRemoteConfig(configUri) {
    return `import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { environment } from 'src/environments/environment';

@Injectable({
  providedIn: 'root'
})
export class AuthConfigService {
  private authConfig;

  constructor(private http: HttpClient) { }

  loadAuthConfig() {
    return this.http.get(\`\${environment.apiUrl}/${configUri}\`)
      .toPromise()
      .then(data => {
        this.authConfig = data;
        // Override issuer and client ID with values from API
        environment.oidcConfig.server_host = this.authConfig.issuer;
        environment.oidcConfig.client_id = this.authConfig.clientId;
      }).catch((error) => {
        console.error('Failed to fetch remote OIDC configuration.');
        console.error(error);
      });
  }

  getConfig() {
    return this.authConfig;
  }
}`;
}
exports.ionicRemoteConfig = ionicRemoteConfig;
//# sourceMappingURL=index.js.map